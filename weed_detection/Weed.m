function [BW, maskedRGBImage, detected_weeds] = Weed(RGB)
    % createMask Threshold RGB image using auto-generated code from colorThresholder app.
    % [BW, MASKEDRGBIMAGE, LARGEST_BLOB_PIXELS] = createMask(RGB) thresholds image RGB using
    % auto-generated code from the colorThresholder app. The colorspace and
    % range for each channel of the colorspace were set within the app. The
    % segmentation mask is returned in BW, a composite of the mask and
    % original RGB images is returned in maskedRGBImage, and the number of
    % pixels for the largest blob is returned in largest_blob_pixels.

    % Auto-generated by colorThresholder app on 27-Jul-2023
    %------------------------------------------------------
    detected_weeds = 0
    % Convert RGB image to chosen color space
    I = imresize(rgb2lab(RGB),[200,200]);  
    %I = imresize(rgb2lab(RGB),[400,400]);

    %lastBrightPixelValue = 0
    % Define thresholds for channel 1 based on histogram settings
    channel1Min = 0.000;
    channel1Max = 82.210;

    % Define thresholds for channel 2 based on histogram settings
    channel2Min = -27.382;
    channel2Max = -19.188;

    % Define thresholds for channel 3 based on histogram settings
    channel3Min = 15.054;
    channel3Max = 26.010;

    % Create mask based on chosen histogram thresholds
    sliderBW = (I(:, :, 1) >= channel1Min) & (I(:, :, 1) <= channel1Max) & ...
               (I(:, :, 2) >= channel2Min) & (I(:, :, 2) <= channel2Max) & ...
               (I(:, :, 3) >= channel3Min) & (I(:, :, 3) <= channel3Max);
    BW = sliderBW;

    % Perform dilation on the binary mask
    se_dilation = strel('disk', 8); % Adjust the disk size as needed
    BW = imdilate(BW, se_dilation);

    % Perform erosion on the dilated mask
    se_erosion = strel('disk', 5); % Adjust the disk size as needed
    BW = imerode(BW, se_erosion);


    % Initialize output masked image based on input image.
    maskedRGBImage = RGB;

    % Set background pixels where BW is false to zero.
    maskedRGBImage(repmat(~BW, [1, 1, 3])) = 0;

    % Count the number of white blobs (connected components) in the eroded mask
    labeled_mask = bwlabel(BW);
    
    % Find the properties of connected components
    blob_props = regionprops(labeled_mask, 'Area');

    % Find the index of the largest blob based on its area
    [~, idx] = max([blob_props.Area]);

    % Get the number of pixels for the largest blob
    %largest_blob_pixels = blob_props(idx).Area;

try
   largest_blob_pixels = blob_props(idx).Area;
catch exception
    largest_blob_pixels = 1;
end
if largest_blob_pixels > 1
    cc = bwconncomp(BW);
    detected_weeds =1
    % Get the properties of the connected components
    props = regionprops(cc, 'Area', 'PixelIdxList');
    
    % Initialize a binary image to retain only the largest blob
    largestBlobImage = false(size(BW));
    
    % Find the largest connected component (blob) based on area
    [~, idx] = max([props.Area]);
    
    % Set the pixels of the largest blob to 1 in the new binary image
    largestBlobImage(cc.PixelIdxList{idx}) = true;
    BW=largestBlobImage;
    
    
    % Step 1: Load the original color image and the binary boundary image
    originalImage = imresize((RGB),[200,200]);   %imread('path_to_original_image.jpg');
    boundaryImage = BW;
    
    % Step 2: Create a binary mask of the white object using the boundary image
    whiteObjectMask = boundaryImage > 0;
    
    % Step 3: Find the boundary coordinates of the white object using bwboundaries
    boundaries = bwboundaries(whiteObjectMask);
    
    % Step 4: Overlay the boundary on the original color image
    figure;
    imshow(originalImage);
    hold on;
    
    for k = 1:length(boundaries)
        boundary = boundaries{k};
        plot(boundary(:, 2), boundary(:, 1), 'r', 'LineWidth', 2);
    end
    
    hold off;
      % Step 5: Save the overlayed colored image
    outputImagePath = 'weed.jpg';
    print(gcf, '-djpeg', '-r300', outputImagePath);

    theoverlayed_image = imread(outputImagePath)


    topic_name = '/weed_detection';
    message_type = 'sensor_msgs/Image';
    weed_detection_pub = rospublisher(topic_name, message_type);

    % Convert the MATLAB image to ROS format (assuming detected_image is in RGB format)
    ros_image = rosmessage('sensor_msgs/Image');
    ros_image.Encoding = 'rgb8';
    ros_image.Width = size(outputImagePath, 2);
    ros_image.Height = size(outputImagePath,1);
    ros_image.Step = 3 * ros_image.Width;
    
    % Convert the RGB image data to uint8 format
    detected_image = uint8(outputImagePath);
    
    % Convert the 3D RGB image to a 1D column vector for ROS
    ros_image.Data =detected_image % reshape(permute(outputImagePath, [3, 1, 2]), 1, []);

    % Publish the image to the /weed_detection topic
    send(weed_detection_pub, ros_image);
end

  
     
    
        if (largest_blob_pixels > 1000)
      % Assuming you have a binary image named 'binaryImage'
    
    % Find the size of the binary image
    [rows, columns] = size(BW);
    
    % Initialize the column value of the first bright pixel from the left
    firstBrightPixelColumn = -1;
    counter = 0
    % Loop through the image columns starting from the leftmost column
    for col = 1:columns
        % Find the white pixels (pixel value == 1) in the current column
        whitePixels = BW(:, col);
        
        % Check if there are any white pixels in the column
        if any(whitePixels)
            % Get the column index of the first white pixel in the column
            firstBrightPixelColumn = col;
            
            % Break the loop since we have found the first bright pixel
            break;
        else
           counter = counter +1;
        end
    end
    
    % Display the result
    if firstBrightPixelColumn ~= -1
        fprintf('First bright pixel column value from the left: %d\n', firstBrightPixelColumn);
    else
        fprintf('No bright pixels found in the image.\n');
    end
    
        end
        %disp(counter)
end