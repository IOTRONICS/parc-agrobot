function [BW,maskedRGBImage,counter ] = redlane(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 28-Jul-2023
%------------------------------------------------------
firstBrightPixelColumn =0;
counter = 1;
% Convert RGB image to chosen color space
%I = rgb2lab(RGB);

I = imresize(rgb2lab(RGB),[300,300]);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 43.139;
channel1Max = 94.937;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 7.792;
channel2Max = 36.503;

% Define thresholds for channel 3 based on histogram settings
channel3Min = -13.830;
channel3Max = 5.688;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Perform dilation on the binary mask
    se_dilation = strel('disk', 8); % Adjust the disk size as needed
    BW = imdilate(BW, se_dilation);

    % Perform erosion on the dilated mask
    se_erosion = strel('disk', 2); % Adjust the disk size as needed
    BW = imerode(BW, se_erosion);

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

% Count the number of white blobs (connected components) in the eroded mask
    labeled_mask = bwlabel(BW);
    
    % Find the properties of connected components
    blob_props = regionprops(labeled_mask, 'Area');

    % Find the index of the largest blob based on its area
    [~, idx] = max([blob_props.Area]);

    % Get the number of pixels for the largest blob
    %largest_blob_pixels = blob_props(idx).Area;
try
   largest_blob_pixels = blob_props(idx).Area;
catch exception
    largest_blob_pixels = 1;
end
cc = bwconncomp(BW);
if (largest_blob_pixels > 1)
% Get the properties of the connected components
props = regionprops(cc, 'Area', 'PixelIdxList');

% Initialize a binary image to retain only the largest blob
largestBlobImage = false(size(BW));

% Find the largest connected component (blob) based on area
[~, idx] = max([props.Area]);

% Set the pixels of the largest blob to 1 in the new binary image
largestBlobImage(cc.PixelIdxList{idx}) = true;
BW=largestBlobImage;


if (largest_blob_pixels > 600)
  % Assuming you have a binary image named 'binaryImage'

% Find the size of the binary image
[rows, columns] = size(BW);

% Initialize the column value of the first bright pixel from the left
firstBrightPixelColumn = -1;
counter = 1;
% Loop through the image columns starting from the leftmost column
%for col = columns:1:columns
for col = columns:-1:1
    % Check if the current column contains any pixel of interest (1)
    if any(BW(:, col))
        % Store the column number and break the loop
        firstBrightPixelColumn = col;
        break;
    end
end
%firstBrightPixelColumn = 
disp(300-firstBrightPixelColumn)
% Display the result
%if firstBrightPixelColumn ~= -1
 %   fprintf('First bright pixel column red lane: %d\n', firstBrightPixelColumn);
%else
  %  fprintf('No bright pixels found in the image.\n');
%end

    end
    %disp(counter)
end
end